#include <stdarg.h>
//#include "enclave_t.h"

#include <stdbool.h>
#include <stdlib.h>
#include <stdint.h>

#define KEYSIZE 256


__attribute__((aligned(4096), noinline))
uint64_t square(uint64_t x) {
    asm volatile("nop" ::: "memory");  // prevent inlining function
    return x << 1;
}

__attribute__((aligned(4096), noinline))
uint64_t multiply(uint64_t x, uint64_t y) {
    asm volatile("nop" ::: "memory");  // prevent inlining function
    return x * y;
}

uint64_t __attribute__((aligned(4096))) mod_exp_inner(uint64_t base, 
        const char* exp, 
        size_t exp_bits,
        uint64_t mod) {
    uint64_t result = 1;
    for(int i = (int)exp_bits - 1; i >= 0; i--) {
        result = square(result);
        if (exp[i] == '1') {
            result = multiply(result, base);
        }
        result = result % mod;
    }
    return result;
}


//static unsigned long next = 0;
//int lcg(void) {
//    next = next * 1103515245 + 12345;
//    return((unsigned)(next/65536) % 32768);
//}
//
//void generate_key() {
//    // set set for LCG
//    next = SEED;
//
//    for (int i = 0; i < KEYSIZE; i++) {
//        key[i] = lcg() % 2 ? '1' : '0';
//    }
//}

const char secret[] = \
"00110100011010010011101111010000001000111101010001111101110010100011000110110000010100010110000100111101111010000011100101000111110000110001110101010100110100101000010010011111101000011101010000100001010100010110001100111010100000100111001100011000100000001010111001101001010101110011110100011000011011000000000010100000000000100010100001010101110101100101110011101000011000110111110110101100001110000010110000000111100111010000000010111100100011111101001111010000110011100000110100110011011011110011000011111001111111001101100010010110011011100001111001111000100101011000010110111111110001110001010011011000101100000111001011111111000011100101001101011011101000111001111011001111110011111100000101000010000010000011100011010011001010110000010000011101010100001000011001110110001000111111000010000010111110111010001011100010011000000000100000111001000110111011000100010101111001111000010101010111101011000000101011111100101001010111110011000100101001101110000100010001000000101011100001010111101001010010101011101101111100010011110111110000100110101010000011101110100001111001110011010011001101010101100010101110100101110001000000100000100100011100111011010100000110101001000100110000110110011100001110001100110001010011111100110010000111000011010111111001111110100100111111101111101011001100001100000000111101000010100111001010010110010100101000110010011000011001010101101111101010010001010001010010011000111111100010101110011110101100100000011111000001010111110001010100101111011111111010000000101011110101000010010001111101100100101001001011001000100010001100100111100000000010101011010100101111010101110000011000010000011100010010010000110000101100000011000101101000001011001111000001111010110011010000011111001111101100000111010100010100101011100100010100001001010000011101010101001100010010101111000100011111000111101001001010101001100001010101011111101011110111000001010001100000110001001011111000000110000110001110101110101100100010010001100111111000100100000001110011111010100001001001010001001000001010100110110110100101101111000110111011";

uint64_t __attribute__((aligned(4096))) mod_exp() {
    uint64_t base = 3;  // plaintext
    uint64_t modulus = 0x80000000;
    return mod_exp_inner(base, secret, sizeof(secret)-1, modulus);
}